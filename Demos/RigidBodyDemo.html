<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Simulate the linear and angular states of a rigid body using "AC.m"</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-01-30">
<meta name="DC.source" content="RigidBodyDemo.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Simulate the linear and angular states of a rigid body using "AC.m"</h1>
<!--introduction-->
<pre class="language-matlab">Four <span class="string">different</span> <span class="string">geometries</span> <span class="string">are</span> <span class="string">available</span> <span class="string">to</span> <span class="string">choose</span> <span class="string">from.</span>
A <span class="string">rotor</span> <span class="string">may</span> <span class="string">be</span> <span class="string">included</span> <span class="string">or</span> <span class="string">omitted.</span>
</pre>
<pre class="language-matlab">The <span class="string">motion</span> <span class="string">is</span> <span class="string">simulated</span> <span class="string">using</span> <span class="string">two</span> <span class="string">different</span> <span class="string">cases.</span>
  <span class="keyword">case</span> 0   --    The origin <span class="string">of</span> <span class="string">the</span> <span class="string">body</span> <span class="string">frame</span> <span class="string">coincides</span> <span class="string">with</span> <span class="string">the</span> <span class="string">CG</span>
  <span class="keyword">case</span> 1   --    The origin <span class="string">of</span> <span class="string">the</span> <span class="string">body</span> <span class="string">frame</span> <span class="string">is</span> <span class="string">translated</span> <span class="string">to</span> <span class="string">a</span> <span class="string">non-CG</span>
                 point
</pre>
<pre class="language-matlab">The <span class="string">inertias</span> <span class="string">for</span> <span class="string">case</span> <span class="string">0</span> <span class="string">and</span> <span class="string">case</span> <span class="string">1</span> <span class="string">are</span> <span class="string">different</span>, according <span class="string">to</span> <span class="string">the</span>
parallel <span class="string">axis</span> <span class="string">theorem.</span>
</pre>
<pre class="language-matlab">The <span class="string">initial</span> <span class="string">angular</span> <span class="string">velocity</span> <span class="string">is</span> <span class="string">different</span> <span class="string">for</span> <span class="string">each</span> <span class="string">case</span> <span class="string">IF</span> <span class="string">the</span> <span class="string">inertia</span>
matrix <span class="string">has</span> <span class="string">non-zero</span> <span class="string">off-diagonal</span> <span class="string">terms.</span>
</pre>
<pre class="language-matlab">No <span class="string">aerodynamic</span> <span class="string">forces</span> <span class="string">or</span> <span class="string">torques</span> <span class="string">are</span> <span class="string">considered.</span>
</pre>
<pre class="language-matlab">VERIFICATION
============
</pre>
<pre class="language-matlab">* The trajectories <span class="string">of</span> <span class="string">both</span> <span class="string">the</span> <span class="string">CG</span> <span class="string">and</span> <span class="string">a</span> <span class="string">non-CG</span> <span class="string">point</span> <span class="string">on</span> <span class="string">the</span> <span class="string">body</span> <span class="string">are</span>
  computed <span class="string">for</span> <span class="string">each</span> <span class="string">case</span>, and <span class="string">the</span> <span class="string">errors</span> <span class="string">are</span> <span class="string">plotted.</span>
</pre>
<pre class="language-matlab">* The total <span class="string">angular</span> <span class="string">momentum</span> <span class="string">(body + rotors)</span> <span class="string">is</span> <span class="string">plotted.</span>
  It <span class="string">should</span> <span class="string">be</span> <span class="string">constant.</span>
</pre>
<pre>------------------------------------------------------------------------
See also QECI, AC, ACInit, @acstate/acstate.m, IConv, QTForm,
TranslateAxes, Constant, TimeGUI, Cross, Dot, Mag, SkewSymm, Unit
------------------------------------------------------------------------</pre>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Paramters</a>
</li>
<li>
<a href="#3">Global for the time GUI</a>
</li>
<li>
<a href="#4">Set up database</a>
</li>
<li>
<a href="#5">Load the standard atmosphere</a>
</li>
<li>
<a href="#6">Control</a>
</li>
<li>
<a href="#7">mass</a>
</li>
<li>
<a href="#8">geometry</a>
</li>
<li>
<a href="#9">inertia matrix</a>
</li>
<li>
<a href="#10">cg location for cases 0, 1</a>
</li>
<li>
<a href="#11">Initial time and state</a>
</li>
<li>
<a href="#12">Initialize the model</a>
</li>
<li>
<a href="#13">Initialize the time display</a>
</li>
<li>
<a href="#14">Compute the angular momentum of the body about the CG for both cases</a>
</li>
<li>
<a href="#15">Compute the angular momentum of the rotors for both cases</a>
</li>
<li>
<a href="#16">Compute the CG position in ECI coordinates</a>
</li>
<li>
<a href="#17">Compute a non-CG position in ECI coordinates</a>
</li>
<li>
<a href="#18">Create the plots</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%    Copyright 2003 Princeton Satellite Systems, Inc.</span>
<span class="comment">%    All rights reserved.</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%   Since version 2.0 (ACT)</span>
<span class="comment">%--------------------------------------------------------------------------</span>
</pre>
<h2 id="2">Paramters</h2>
<pre class="codeinput">
<span class="comment">%-------------------------</span>

<span class="comment">% rotor     (1)  Flag 0,1 -- indicating whether to include a rotor or not</span>
rotor = 1;

<span class="comment">% geometry  (1)  Number 1,2,3,4 -- indicating the type of geometry to use</span>
<span class="comment">%                 1 - Hemisphere                (inertia is pure diagonal)</span>
<span class="comment">%                 2 - Cylinder                  (inertia is pure diagonal)</span>
<span class="comment">%                 3 - Rectangular Tetrahedron   (inertia has off-diagonal terms)</span>
<span class="comment">%                 4 - Half-Cone                 (inertia has off-diagonal terms)</span>
geometry = 4;
</pre>
<h2 id="3">Global for the time GUI</h2>
<pre class="codeinput">
<span class="comment">%------------------------</span>
<span class="keyword">global</span> simulationAction
simulationAction = <span class="string">' '</span>;
</pre>
<h2 id="4">Set up database</h2>
<pre class="codeinput">
<span class="comment">%----------------</span>
d.mu            = 1.407644155238e+16;
d.name          = <span class="string">'RigidBody'</span>;
d.theta0        = 0;
d.wPlanet       = [0;0;0];
d.actuator.name = [];
d.aero.name     = [];
d.engine.name   = [];
d.sensor.name   = [];
d.disturb.name  = [];
d.wind.name     = [];
d.flex          = [];

<span class="keyword">if</span>( rotor )
   d.rotor.inertia = 2;
   d.rotor.u       = Unit([1;-2;3]);
   d.rotor.name    = [];
<span class="keyword">else</span>
   d.rotor = [];
<span class="keyword">end</span>
</pre>
<h2 id="5">Load the standard atmosphere</h2>
<pre class="codeinput">
<span class="comment">%-----------------------------</span>
d.atmData       = load(<span class="string">'AtmData.txt'</span>);
d.atmUnits      = <span class="string">'eng'</span>;
</pre>
<h2 id="6">Control</h2>
<pre class="codeinput">
<span class="comment">%--------</span>
d.control.throttle  =  0;
d.control.elevator  =  0;
d.control.aileron   =  0;
d.control.rudder    =  0;
</pre>
<h2 id="7">mass</h2>
<pre class="codeinput">
<span class="comment">%-----</span>
mass = 1;   <span class="comment">% [slug]</span>
</pre>
<h2 id="8">geometry</h2>
<pre class="codeinput">
<span class="comment">%---------</span>
<span class="keyword">switch</span> geometry

<span class="keyword">case</span> 1   <span class="comment">% hemisphere</span>

   R    = 2;   <span class="comment">% radius</span>
   mass = 1;   <span class="comment">% mass [slug]</span>

   <span class="comment">% cg location (translated axes)</span>
   cg   = [0;0;-3*R/8];

   <span class="comment">% inertia elements (about CG)</span>
   Ixx = (83/320)*mass*R^2;
   Iyy = (83/320)*mass*R^2;
   Izz =  (2/5)  *mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = 0;

<span class="keyword">case</span> 2   <span class="comment">% cylinder</span>

   R    = 3;   <span class="comment">% radius</span>
   L    = 10;  <span class="comment">% length</span>
   mass = 1;   <span class="comment">% mass [slug]</span>

   <span class="comment">% cg location (translated axes)</span>
   cg   = [0;0;-L/2];

   <span class="comment">% inertia elements (about CG)</span>
   Ixx = (1/4)*mass*R^2 + (1/12)*mass*L^2;
   Iyy = (1/4)*mass*R^2 + (1/12)*mass*L^2;
   Izz = (1/2)*mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = 0;

<span class="keyword">case</span> 3   <span class="comment">% rectangular tetrahedron</span>

   a = 1;      <span class="comment">% x dimension</span>
   b = 2;      <span class="comment">% y dimension</span>
   c = 3;      <span class="comment">% z dimension</span>

   <span class="comment">% cg location (translated axes)</span>
   cg   = [a;b;c]/4;

   <span class="comment">% inertia elements (about CG)</span>
   Ixx =  (3/80)*mass*(b^2 + c^2);
   Iyy =  (3/80)*mass*(a^2 + c^2);
   Izz =  (3/80)*mass*(a^2 + b^2);
   Ixy = -(1/80)*mass*a*b;
   Ixz = -(1/80)*mass*a*c;
   Iyz = -(1/80)*mass*b*c;

<span class="keyword">case</span> 4   <span class="comment">% half-cone</span>

   R    = 2;   <span class="comment">% radius</span>
   L    = 5;   <span class="comment">% length</span>
   mass = 1;   <span class="comment">% mass [slug]</span>

   <span class="comment">% cg location (translated axes)</span>
   cg   = [0;-R/pi;-L/4];

   <span class="comment">% inertia elements (about CG)</span>
   Ixx = (3/20-1/pi/pi)*mass*R^2 + 3/80*mass*L^2;
   Iyy = (3/20)        *mass*R^2 + 3/80*mass*L^2;
   Izz = (3/10-1/pi/pi)*mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = -1/(20*pi)*mass*R*L;

<span class="keyword">end</span>
</pre>
<h2 id="9">inertia matrix</h2>
<pre class="codeinput">
<span class="comment">%---------------</span>
inertia0  = [Ixx;  Iyy;  Izz;  Ixy; Ixz; Iyz];     <span class="comment">% inertia matrix, case 0</span>
inertia1  = TranslateAxes( inertia0, -cg, mass );  <span class="comment">% inertia matrix, case 1</span>
</pre>
<h2 id="10">cg location for cases 0, 1</h2>
<pre class="codeinput">
<span class="comment">%---------------------------</span>
cG0       = [0;0;0];          <span class="comment">% cg location in body frame, case 0</span>
cG1       = cg;               <span class="comment">% cg location in body frame, case 1</span>

Re        = Constant(<span class="string">'equatorial radius earth'</span>) * 1e3 / Constant(<span class="string">'ft to m'</span>);
rCG       = [Re+150;0;0];     <span class="comment">% initial ECI coordinates of CG (same for both cases)</span>
vCG       = [15; 15; 0];      <span class="comment">% initial velocity of CG in body frame (same for both cases)</span>

i0        = IConv(inertia0);
i1        = IConv(inertia1);
m1        = SkewSymm(cG1);

wCG       = [0;2;0];          <span class="comment">% angular velocity of rigid body in body frame (same for both cases)</span>
HCG       = i0*wCG;           <span class="comment">% angular momentum about CG</span>
w0        = i0\(HCG);         <span class="comment">% angular velocity, case 0 (should equal wCG)</span>
w1        = (i1+m1*m1)\(HCG); <span class="comment">% angular velocity, case 1 (will equal wCG if inertia matrix is diagonal)</span>

eulInit   = [0;0;0];               <span class="comment">% initial orientation (aligned x-north, y-east, z-down)</span>
q         = QECI( rCG, eulInit );  <span class="comment">% initial ECI to body quaternion (same for both cases</span>

r0i       = rCG - QTForm(q,cG0);   <span class="comment">% ECI coordinates of body frame origin, case 0</span>
r1i       = rCG - QTForm(q,cG1);   <span class="comment">% ECI coordinates of body frame origin, case 1</span>

v0i       = vCG + Cross(w0,-cG0);  <span class="comment">% initial velocity of origin in body frame, case 0</span>
v1i       = vCG + Cross(w1,-cG1);  <span class="comment">% initial velocity of origin in body frame, case 1</span>

wR        = ones(length(d.rotor),1)*5;
engine    = [];
actuator  = [];
sensor    = [];
flex      = [];
disturb   = [];
</pre>
<h2 id="11">Initial time and state</h2>
<pre class="codeinput">
<span class="comment">%-----------------------</span>
t  = 0;
x0 = acstate( r0i, q, w0, v0i, wR, mass, inertia0, cG0, engine, actuator, sensor, flex, disturb );
x1 = acstate( r1i, q, w1, v1i, wR, mass, inertia1, cG1, engine, actuator, sensor, flex, disturb );
</pre>
<h2 id="12">Initialize the model</h2>
<pre class="codeinput">
<span class="comment">%---------------------</span>
dT   = 0.01;
nSim = 10/dT;

d0   = ACInit( x0, d );
d1   = ACInit( x1, d );

nR  = d0.nRotors;

r0  = zeros(3,nSim);
v0  = zeros(3,nSim);
q0  = zeros(4,nSim);
w0  = zeros(3,nSim);
wR0 = zeros(nR,nSim);
r1  = zeros(3,nSim);
v1  = zeros(3,nSim);
q1  = zeros(4,nSim);
w1  = zeros(3,nSim);
wR1 = zeros(nR,nSim);
</pre>
<h2 id="13">Initialize the time display</h2>
<pre class="codeinput">
<span class="comment">%----------------------------</span>
tToGoMem.lastJD        = 0;
tToGoMem.lastStepsDone = 0;
tToGoMem.kAve          = 0;
[ ratioRealTime, tToGoMem ] =  TimeGUI( nSim, 0, tToGoMem, 0, dT,<span class="keyword">...</span>
    <span class="string">'Testing Equations of Motion for AC.m'</span> );

<span class="keyword">for</span> k = 1:nSim

   <span class="comment">% Display the status message</span>
   <span class="comment">%---------------------------</span>
   [ ratioRealTime, tToGoMem ] = TimeGUI( nSim, k, tToGoMem, ratioRealTime, dT );

   <span class="comment">% Store for Plotting</span>
   <span class="comment">%-------------------</span>
   r0(:,k) = get(x0,<span class="string">'r'</span>);
   v0(:,k) = get(x0,<span class="string">'v'</span>);
   q0(:,k) = get(x0,<span class="string">'q'</span>);
   w0(:,k) = get(x0,<span class="string">'w'</span>);
   r1(:,k) = get(x1,<span class="string">'r'</span>);
   v1(:,k) = get(x1,<span class="string">'v'</span>);
   q1(:,k) = get(x1,<span class="string">'q'</span>);
   w1(:,k) = get(x1,<span class="string">'w'</span>);

   wR0(:,k) = get(x0,<span class="string">'wR'</span>);
   wR1(:,k) = get(x1,<span class="string">'wR'</span>);

   <span class="comment">% The simulation</span>
   <span class="comment">%---------------</span>
   x0    = AC( x0, t, dT, d0  );
   x1    = AC( x1, t, dT, d1 );
   t     = t + dT;

   <span class="comment">% Time control</span>
   <span class="comment">%-------------</span>
   <span class="keyword">switch</span> simulationAction
   <span class="keyword">case</span> <span class="string">'pause'</span>
      pause
      simulationAction = <span class="string">' '</span>;
   <span class="keyword">case</span> <span class="string">'stop'</span>
      <span class="keyword">return</span>;
   <span class="keyword">case</span> <span class="string">'plot'</span>
      <span class="keyword">break</span>;
   <span class="keyword">end</span>

<span class="keyword">end</span>

TimeGUI(<span class="string">'close'</span>);
t   = (1:k)*dT;
r0  = r0(:,1:k);
v0  = v0(:,1:k);
q0  = q0(:,1:k);
w0  = w0(:,1:k);
wR0 = wR0(:,1:k);
r1  = r1(:,1:k);
v1  = v1(:,1:k);
q1  = q1(:,1:k);
w1  = w1(:,1:k);
wR1 = wR1(:,1:k);
</pre>
<h2 id="14">Compute the angular momentum of the body about the CG for both cases</h2>
<pre class="codeinput">
<span class="comment">%---------------------------------------------------------------------</span>
H0   = i0*w0 - mass*Cross(cG0,Cross(w0,cG0));
H1   = i1*w1 - mass*Cross(cG1,Cross(w1,cG1));
</pre>
<h2 id="15">Compute the angular momentum of the rotors for both cases</h2>
<pre class="codeinput">
<span class="comment">%----------------------------------------------------------</span>
HR0 = zeros(3,k);
HR1 = zeros(3,k);
<span class="keyword">for</span> i=1:nR
   HR0 = HR0 + d0.rotor(i).inertia*d0.rotor(i).u*(wR0(i,:)+Dot(d0.rotor(i).u,w0));
   HR1 = HR1 + d1.rotor(i).inertia*d1.rotor(i).u*(wR1(i,:)+Dot(d1.rotor(i).u,w1));
<span class="keyword">end</span>


fprintf(<span class="string">'2-norm of angular momentum difference: %f\n'</span>,norm( (H0+HR0)-(H1+HR1) ) )
</pre>
<pre class="codeoutput">2-norm of angular momentum difference: 0.000000
</pre>
<h2 id="16">Compute the CG position in ECI coordinates</h2>
<pre class="codeinput">
<span class="comment">%-------------------------------------------</span>
rCG0 = r0 + QTForm( q0, cG0 );
rCG1 = r1 + QTForm( q1, cG1 );
rCG3 = rCG*(t./t) + vCG*t - 0.5*[32.1;0;0]*(t.*t);
</pre>
<h2 id="17">Compute a non-CG position in ECI coordinates</h2>
<pre class="codeinput">
<span class="comment">%---------------------------------------------</span>
x     = -cG1;
rNCG0 = r0 + QTForm( q0, cG0 + x );
rNCG1 = r1 + QTForm( q1, cG1 + x );
</pre>
<h2 id="18">Create the plots</h2>
<pre class="codeinput">
<span class="comment">%-----------------</span>
figure, plot(t,Mag(H0),<span class="string">'k'</span>,t,Mag(H1),<span class="string">'m--'</span>,<span class="string">'linewidth'</span>,4), hold <span class="string">on</span>
c = get(gca,<span class="string">'colororder'</span>);
c = [c(1:3,1:3); c(1:3,1:3)];
set(gca,<span class="string">'colororder'</span>,c)
plot(t,H0,t,H1,<span class="string">'--'</span>,<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>
title(<span class="string">'Angular Momentum (Body)'</span>,<span class="string">'fontsize'</span>,14)
legend(<span class="string">'case 0'</span>,<span class="string">'case 1'</span>);
ylabel(<span class="string">'|H_B|'</span>,<span class="string">'fontsize'</span>,14);
xlabel(<span class="string">'Time [sec]'</span>,<span class="string">'fontsize'</span>,14);
set(gca,<span class="string">'fontsize'</span>,14);

<span class="keyword">if</span>( nR &gt; 0 )
   figure, plot(t,Mag(HR0),<span class="string">'k'</span>,t,Mag(HR1),<span class="string">'m--'</span>,<span class="string">'linewidth'</span>,4), hold <span class="string">on</span>
   set(gca,<span class="string">'colororder'</span>,c)
   plot(t,HR0,t,HR1,<span class="string">'--'</span>,<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>
   title(<span class="string">'Angular Momentum (Rotors)'</span>,<span class="string">'fontsize'</span>,14)
   legend(<span class="string">'case 0'</span>,<span class="string">'case 1'</span>);
   ylabel(<span class="string">'|H_R|'</span>,<span class="string">'fontsize'</span>,14);
   xlabel(<span class="string">'Time [sec]'</span>,<span class="string">'fontsize'</span>,14);
   set(gca,<span class="string">'fontsize'</span>,14);
   figure, plot(t,Mag(H0+HR0),<span class="string">'k'</span>,t,Mag(H1+HR1),<span class="string">'m--'</span>,<span class="string">'linewidth'</span>,4), hold <span class="string">on</span>
   set(gca,<span class="string">'colororder'</span>,c)
   plot(t,H0+HR0,t,H1+HR1,<span class="string">'--'</span>,<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>
   title(<span class="string">'Angular Momentum (Body plus Rotors)'</span>,<span class="string">'fontsize'</span>,14)
   legend(<span class="string">'case 0'</span>,<span class="string">'case 1'</span>);
   ylabel(<span class="string">'|H_B+H_R|'</span>,<span class="string">'fontsize'</span>,14);
   xlabel(<span class="string">'Time [sec]'</span>,<span class="string">'fontsize'</span>,14);
   set(gca,<span class="string">'fontsize'</span>,14);
<span class="keyword">end</span>

figure,
subplot(311)
plot(t,rCG0(1,:)-rCG1(1,:),<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
title(<span class="string">'ECI Position Error of CG [ft]'</span>,<span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'x'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);
subplot(312)
plot(t,rCG0(2,:)-rCG1(2,:),<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'y'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);
subplot(313)
plot(t,rCG0(3,:)-rCG1(3,:),<span class="string">'linewidth'</span>,3), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
xlabel(<span class="string">'Time [sec]'</span>,<span class="string">'fontsize'</span>,14);
ylabel(<span class="string">'z'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);

figure,
subplot(311)
plot(t,rNCG0(1,:)-rNCG1(1,:),<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
title(<span class="string">'ECI Position Error of Non-CG [ft]'</span>,<span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'x'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);
subplot(312)
plot(t,rNCG0(2,:)-rNCG1(2,:),<span class="string">'linewidth'</span>,2), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'y'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);
subplot(313)
plot(t,rNCG0(3,:)-rNCG1(3,:),<span class="string">'linewidth'</span>,3), grid <span class="string">on</span>, zoom <span class="string">on</span>,
set(gca,<span class="string">'fontsize'</span>,14)
xlabel(<span class="string">'Time [sec]'</span>,<span class="string">'fontsize'</span>,14);
ylabel(<span class="string">'z'</span>,<span class="string">'rotation'</span>,0,<span class="string">'fontsize'</span>,14);

assignin(<span class="string">'base'</span>,<span class="string">'t'</span>, t );
assignin(<span class="string">'base'</span>,<span class="string">'q0'</span>,q0);
assignin(<span class="string">'base'</span>,<span class="string">'q1'</span>,q1);
assignin(<span class="string">'base'</span>,<span class="string">'r0'</span>,r0);
assignin(<span class="string">'base'</span>,<span class="string">'r1'</span>,r1);
assignin(<span class="string">'base'</span>,<span class="string">'v0'</span>,v0);
assignin(<span class="string">'base'</span>,<span class="string">'v1'</span>,v1);
assignin(<span class="string">'base'</span>,<span class="string">'w0'</span>,w0);
assignin(<span class="string">'base'</span>,<span class="string">'w1'</span>,w1);
assignin(<span class="string">'base'</span>,<span class="string">'i0'</span>,i0);
assignin(<span class="string">'base'</span>,<span class="string">'i1'</span>,i1);
assignin(<span class="string">'base'</span>,<span class="string">'cG0'</span>,cG0);
assignin(<span class="string">'base'</span>,<span class="string">'cG1'</span>,cG1);


<span class="comment">%--------------------------------------</span>

<span class="comment">% $Id: cefef484f8ce22d677f08c9c421961eea7a02910 $</span>
</pre>
<img vspace="5" hspace="5" src="RigidBodyDemo_01.png" alt=""> <img vspace="5" hspace="5" src="RigidBodyDemo_02.png" alt=""> <img vspace="5" hspace="5" src="RigidBodyDemo_03.png" alt=""> <img vspace="5" hspace="5" src="RigidBodyDemo_04.png" alt=""> <img vspace="5" hspace="5" src="RigidBodyDemo_05.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Simulate the linear and angular states of a rigid body using "AC.m" 
%
%   Four different geometries are available to choose from. 
%   A rotor may be included or omitted.
%
%   The motion is simulated using two different cases. 
%     case 0   REPLACE_WITH_DASH_DASH    The origin of the body frame coincides with the CG
%     case 1   REPLACE_WITH_DASH_DASH    The origin of the body frame is translated to a non-CG 
%                    point
%
%   The inertias for case 0 and case 1 are different, according to the 
%   parallel axis theorem. 
%
%   The initial angular velocity is different for each case IF the inertia 
%   matrix has non-zero off-diagonal terms.
%
%   No aerodynamic forces or torques are considered.
%
%   VERIFICATION
%   ============
%
%   * The trajectories of both the CG and a non-CG point on the body are 
%     computed for each case, and the errors are plotted. 
%
%   * The total angular momentum (body + rotors) is plotted. 
%     It should be constant.
%
%  REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%  See also QECI, AC, ACInit, @acstate/acstate.m, IConv, QTForm,
%  TranslateAxes, Constant, TimeGUI, Cross, Dot, Mag, SkewSymm, Unit
%  REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%%
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%    Copyright 2003 Princeton Satellite Systems, Inc.
%    All rights reserved.
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%   Since version 2.0 (ACT)
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH


%% Paramters
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

% rotor     (1)  Flag 0,1 REPLACE_WITH_DASH_DASH indicating whether to include a rotor or not
rotor = 1;  

% geometry  (1)  Number 1,2,3,4 REPLACE_WITH_DASH_DASH indicating the type of geometry to use
%                 1 - Hemisphere                (inertia is pure diagonal)
%                 2 - Cylinder                  (inertia is pure diagonal)
%                 3 - Rectangular Tetrahedron   (inertia has off-diagonal terms)
%                 4 - Half-Cone                 (inertia has off-diagonal terms)
geometry = 4;


%% Global for the time GUI
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
global simulationAction
simulationAction = ' ';

%% Set up database
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
d.mu            = 1.407644155238e+16;
d.name          = 'RigidBody';
d.theta0        = 0;
d.wPlanet       = [0;0;0];
d.actuator.name = [];
d.aero.name     = [];
d.engine.name   = [];
d.sensor.name   = [];
d.disturb.name  = [];
d.wind.name     = [];
d.flex          = [];

if( rotor )
   d.rotor.inertia = 2;
   d.rotor.u       = Unit([1;-2;3]);
   d.rotor.name    = [];
else
   d.rotor = [];
end

%% Load the standard atmosphere
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
d.atmData       = load('AtmData.txt');
d.atmUnits      = 'eng';

%% Control
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
d.control.throttle  =  0;
d.control.elevator  =  0;
d.control.aileron   =  0;
d.control.rudder    =  0;

%% mass
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
mass = 1;   % [slug]

%% geometry
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
switch geometry

case 1   % hemisphere

   R    = 2;   % radius
   mass = 1;   % mass [slug]
   
   % cg location (translated axes)
   cg   = [0;0;-3*R/8];
   
   % inertia elements (about CG)
   Ixx = (83/320)*mass*R^2;
   Iyy = (83/320)*mass*R^2;
   Izz =  (2/5)  *mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = 0;
      
case 2   % cylinder

   R    = 3;   % radius
   L    = 10;  % length
   mass = 1;   % mass [slug]
   
   % cg location (translated axes)
   cg   = [0;0;-L/2];
   
   % inertia elements (about CG)
   Ixx = (1/4)*mass*R^2 + (1/12)*mass*L^2;
   Iyy = (1/4)*mass*R^2 + (1/12)*mass*L^2;
   Izz = (1/2)*mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = 0;
   
case 3   % rectangular tetrahedron
   
   a = 1;      % x dimension
   b = 2;      % y dimension
   c = 3;      % z dimension
   
   % cg location (translated axes)
   cg   = [a;b;c]/4;
   
   % inertia elements (about CG)
   Ixx =  (3/80)*mass*(b^2 + c^2);
   Iyy =  (3/80)*mass*(a^2 + c^2);
   Izz =  (3/80)*mass*(a^2 + b^2);
   Ixy = -(1/80)*mass*a*b;
   Ixz = -(1/80)*mass*a*c;
   Iyz = -(1/80)*mass*b*c;
         
case 4   % half-cone

   R    = 2;   % radius
   L    = 5;   % length
   mass = 1;   % mass [slug]
   
   % cg location (translated axes)
   cg   = [0;-R/pi;-L/4];
   
   % inertia elements (about CG)
   Ixx = (3/20-1/pi/pi)*mass*R^2 + 3/80*mass*L^2;
   Iyy = (3/20)        *mass*R^2 + 3/80*mass*L^2;
   Izz = (3/10-1/pi/pi)*mass*R^2;
   Ixy = 0;
   Ixz = 0;
   Iyz = -1/(20*pi)*mass*R*L;
      
end

%% inertia matrix
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
inertia0  = [Ixx;  Iyy;  Izz;  Ixy; Ixz; Iyz];     % inertia matrix, case 0
inertia1  = TranslateAxes( inertia0, -cg, mass );  % inertia matrix, case 1

%% cg location for cases 0, 1
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
cG0       = [0;0;0];          % cg location in body frame, case 0
cG1       = cg;               % cg location in body frame, case 1

Re        = Constant('equatorial radius earth') * 1e3 / Constant('ft to m');
rCG       = [Re+150;0;0];     % initial ECI coordinates of CG (same for both cases)
vCG       = [15; 15; 0];      % initial velocity of CG in body frame (same for both cases)

i0        = IConv(inertia0);
i1        = IConv(inertia1);
m1        = SkewSymm(cG1);

wCG       = [0;2;0];          % angular velocity of rigid body in body frame (same for both cases)
HCG       = i0*wCG;           % angular momentum about CG
w0        = i0\(HCG);         % angular velocity, case 0 (should equal wCG)
w1        = (i1+m1*m1)\(HCG); % angular velocity, case 1 (will equal wCG if inertia matrix is diagonal)

eulInit   = [0;0;0];               % initial orientation (aligned x-north, y-east, z-down)
q         = QECI( rCG, eulInit );  % initial ECI to body quaternion (same for both cases

r0i       = rCG - QTForm(q,cG0);   % ECI coordinates of body frame origin, case 0
r1i       = rCG - QTForm(q,cG1);   % ECI coordinates of body frame origin, case 1

v0i       = vCG + Cross(w0,-cG0);  % initial velocity of origin in body frame, case 0
v1i       = vCG + Cross(w1,-cG1);  % initial velocity of origin in body frame, case 1

wR        = ones(length(d.rotor),1)*5;
engine    = [];
actuator  = [];
sensor    = [];
flex      = [];
disturb   = [];


%% Initial time and state
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
t  = 0;
x0 = acstate( r0i, q, w0, v0i, wR, mass, inertia0, cG0, engine, actuator, sensor, flex, disturb );
x1 = acstate( r1i, q, w1, v1i, wR, mass, inertia1, cG1, engine, actuator, sensor, flex, disturb );

%% Initialize the model
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
dT   = 0.01;
nSim = 10/dT;

d0   = ACInit( x0, d );
d1   = ACInit( x1, d );

nR  = d0.nRotors;

r0  = zeros(3,nSim);
v0  = zeros(3,nSim);
q0  = zeros(4,nSim);
w0  = zeros(3,nSim);
wR0 = zeros(nR,nSim);
r1  = zeros(3,nSim);
v1  = zeros(3,nSim);
q1  = zeros(4,nSim);
w1  = zeros(3,nSim);
wR1 = zeros(nR,nSim);

%% Initialize the time display
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
tToGoMem.lastJD        = 0; 
tToGoMem.lastStepsDone = 0; 
tToGoMem.kAve          = 0;
[ ratioRealTime, tToGoMem ] =  TimeGUI( nSim, 0, tToGoMem, 0, dT,...
    'Testing Equations of Motion for AC.m' );

for k = 1:nSim
   
   % Display the status message
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
   [ ratioRealTime, tToGoMem ] = TimeGUI( nSim, k, tToGoMem, ratioRealTime, dT );
   
   % Store for Plotting
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
   r0(:,k) = get(x0,'r');
   v0(:,k) = get(x0,'v');
   q0(:,k) = get(x0,'q');
   w0(:,k) = get(x0,'w');
   r1(:,k) = get(x1,'r');
   v1(:,k) = get(x1,'v');
   q1(:,k) = get(x1,'q');
   w1(:,k) = get(x1,'w');
   
   wR0(:,k) = get(x0,'wR');
   wR1(:,k) = get(x1,'wR');
   
   % The simulation
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
   x0    = AC( x0, t, dT, d0  );
   x1    = AC( x1, t, dT, d1 );
   t     = t + dT;
   
   % Time control
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
   switch simulationAction
   case 'pause'
      pause
      simulationAction = ' ';
   case 'stop'
      return;
   case 'plot'
      break;
   end

end

TimeGUI('close');
t   = (1:k)*dT;
r0  = r0(:,1:k);
v0  = v0(:,1:k);
q0  = q0(:,1:k);
w0  = w0(:,1:k);
wR0 = wR0(:,1:k);
r1  = r1(:,1:k);
v1  = v1(:,1:k);
q1  = q1(:,1:k);
w1  = w1(:,1:k);
wR1 = wR1(:,1:k);

%% Compute the angular momentum of the body about the CG for both cases
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
H0   = i0*w0 - mass*Cross(cG0,Cross(w0,cG0));
H1   = i1*w1 - mass*Cross(cG1,Cross(w1,cG1));

%% Compute the angular momentum of the rotors for both cases
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
HR0 = zeros(3,k);
HR1 = zeros(3,k);
for i=1:nR
   HR0 = HR0 + d0.rotor(i).inertia*d0.rotor(i).u*(wR0(i,:)+Dot(d0.rotor(i).u,w0));
   HR1 = HR1 + d1.rotor(i).inertia*d1.rotor(i).u*(wR1(i,:)+Dot(d1.rotor(i).u,w1));
end


fprintf('2-norm of angular momentum difference: %f\n',norm( (H0+HR0)-(H1+HR1) ) )

%% Compute the CG position in ECI coordinates
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
rCG0 = r0 + QTForm( q0, cG0 );
rCG1 = r1 + QTForm( q1, cG1 );
rCG3 = rCG*(t./t) + vCG*t - 0.5*[32.1;0;0]*(t.*t);

%% Compute a non-CG position in ECI coordinates
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
x     = -cG1;
rNCG0 = r0 + QTForm( q0, cG0 + x );
rNCG1 = r1 + QTForm( q1, cG1 + x );

%% Create the plots
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
figure, plot(t,Mag(H0),'k',t,Mag(H1),'mREPLACE_WITH_DASH_DASH','linewidth',4), hold on
c = get(gca,'colororder');
c = [c(1:3,1:3); c(1:3,1:3)];
set(gca,'colororder',c)
plot(t,H0,t,H1,'REPLACE_WITH_DASH_DASH','linewidth',2), grid on, zoom on
title('Angular Momentum (Body)','fontsize',14)
legend('case 0','case 1');
ylabel('|H_B|','fontsize',14);
xlabel('Time [sec]','fontsize',14);
set(gca,'fontsize',14);

if( nR > 0 )
   figure, plot(t,Mag(HR0),'k',t,Mag(HR1),'mREPLACE_WITH_DASH_DASH','linewidth',4), hold on
   set(gca,'colororder',c)
   plot(t,HR0,t,HR1,'REPLACE_WITH_DASH_DASH','linewidth',2), grid on, zoom on
   title('Angular Momentum (Rotors)','fontsize',14)
   legend('case 0','case 1');
   ylabel('|H_R|','fontsize',14);
   xlabel('Time [sec]','fontsize',14);
   set(gca,'fontsize',14);
   figure, plot(t,Mag(H0+HR0),'k',t,Mag(H1+HR1),'mREPLACE_WITH_DASH_DASH','linewidth',4), hold on
   set(gca,'colororder',c)
   plot(t,H0+HR0,t,H1+HR1,'REPLACE_WITH_DASH_DASH','linewidth',2), grid on, zoom on
   title('Angular Momentum (Body plus Rotors)','fontsize',14)
   legend('case 0','case 1');
   ylabel('|H_B+H_R|','fontsize',14);
   xlabel('Time [sec]','fontsize',14);
   set(gca,'fontsize',14);
end

figure, 
subplot(311)
plot(t,rCG0(1,:)-rCG1(1,:),'linewidth',2), grid on, zoom on,
set(gca,'fontsize',14)
title('ECI Position Error of CG [ft]','fontsize',14)
ylabel('x','rotation',0,'fontsize',14);
subplot(312)
plot(t,rCG0(2,:)-rCG1(2,:),'linewidth',2), grid on, zoom on,
set(gca,'fontsize',14)
ylabel('y','rotation',0,'fontsize',14);
subplot(313)
plot(t,rCG0(3,:)-rCG1(3,:),'linewidth',3), grid on, zoom on,
set(gca,'fontsize',14)
xlabel('Time [sec]','fontsize',14);
ylabel('z','rotation',0,'fontsize',14);

figure, 
subplot(311)
plot(t,rNCG0(1,:)-rNCG1(1,:),'linewidth',2), grid on, zoom on,
set(gca,'fontsize',14)
title('ECI Position Error of Non-CG [ft]','fontsize',14)
ylabel('x','rotation',0,'fontsize',14);
subplot(312)
plot(t,rNCG0(2,:)-rNCG1(2,:),'linewidth',2), grid on, zoom on,
set(gca,'fontsize',14)
ylabel('y','rotation',0,'fontsize',14);
subplot(313)
plot(t,rNCG0(3,:)-rNCG1(3,:),'linewidth',3), grid on, zoom on,
set(gca,'fontsize',14)
xlabel('Time [sec]','fontsize',14);
ylabel('z','rotation',0,'fontsize',14);

assignin('base','t', t );
assignin('base','q0',q0);
assignin('base','q1',q1);
assignin('base','r0',r0);
assignin('base','r1',r1);
assignin('base','v0',v0);
assignin('base','v1',v1);
assignin('base','w0',w0);
assignin('base','w1',w1);
assignin('base','i0',i0);
assignin('base','i1',i1);
assignin('base','cG0',cG0);
assignin('base','cG1',cG1);


%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% $Date:   RigidBodyDemo.m $
% $Id: cefef484f8ce22d677f08c9c421961eea7a02910 $

##### SOURCE END #####
-->
</body>
</html>
